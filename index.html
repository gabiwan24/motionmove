<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>MOTION SVG mit Gyroskop (Gravitation)</title>
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden; /* Verhindert Scrollen auf Mobilgeräten */
    }
    body {
      margin: 0;
      display: grid;
      place-items: center;
      background: #111;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }
    
    svg {
      width: min(95vw, calc(95vh * 16 / 9));
      aspect-ratio: 16 / 9;
      display: block;
      overflow: hidden; 
    }

    #permission-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      text-align: center;
      color: white;
      padding: 20px;
      z-index: 10;
    }

    #permission-button {
      font-size: 1.2rem;
      padding: 15px 30px;
      margin-top: 20px;
      border-radius: 12px;
      border: 1px solid #fff;
      background-color: #333;
      color: #fff;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.2s;
    }

    #version-display {
      position: absolute;
      top: 15px;
      left: 15px;
      color: rgba(255, 255, 255, 0.3);
      font-size: 14px;
      z-index: 5;
    }
  </style>
</head>
<body>

  <div id="version-display">v1.5</div>

  <div id="permission-overlay">
    <h1>Gyro-Gravitation</h1>
    <p>Bitte tippen, um den Zugriff auf die Bewegungssensoren zu erlauben.</p>
    <button id="permission-button">Starten</button>
  </div>

  <svg id="motion-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1920 1080" fill="white">
    <rect id="gyro-square" x="0" y="0" width="400" height="400" />
  </svg>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const permissionOverlay = document.getElementById('permission-overlay');
      const permissionButton = document.getElementById('permission-button');
      
      const square = document.getElementById('gyro-square');
      const viewBox = { width: 1920, height: 1080 };

      const squareProps = {
        width: parseFloat(square.getAttribute('width')),
        height: parseFloat(square.getAttribute('height')),
      };

      const initialX = (viewBox.width - squareProps.width) / 2;
      const initialY = (viewBox.height - squareProps.height) / 2;
      gsap.set(square, { x: initialX, y: initialY });

      // =================================================================
      // NEUE ANIMATIONS-ENGINE
      // =================================================================
      let forceX = 0, forceY = 0;
      let currentTranslateX = 0, currentTranslateY = 0;
      let currentScaleX = 1, currentScaleY = 1;

      const collisionState = { left: false, right: false, top: false, bottom: false };
      
      function handleOrientation(event) {
        const gamma = event.gamma || 0; 
        const beta = event.beta || 0;   

        const maxTilt = 45.0; 
        const deadzone = 1.0; 

        // Diese Funktion aktualisiert nur noch die "Kräfte", die in der Schleife wirken
        let newForceX = 0;
        if (Math.abs(gamma) > deadzone) {
            newForceX = gsap.utils.clamp(-1, 1, gamma / maxTilt);
        }
        forceX = newForceX;
        
        let newForceY = 0;
        const calibratedBeta = beta - 45;
        if (Math.abs(calibratedBeta) > deadzone) {
            newForceY = gsap.utils.clamp(-1, 1, calibratedBeta / maxTilt);
        }
        forceY = newForceY;
      }

      function updateAnimation() {
        const flowSpeed = 0.8; // Wie schnell das Quadrat auf die Neigung reagiert
        const returnSpeed = 0.05; // Wie schnell es in die Mitte zurückkehrt (Dämpfung)
        const maxStretchFactor = 3.0;

        // Berechne die Ziel-Transformation basierend auf der aktuellen Kraft
        let targetScaleX = 1 + Math.abs(forceX) * (maxStretchFactor - 1);
        let targetScaleY = 1 + Math.abs(forceY) * (maxStretchFactor - 1);
        let targetTranslateX = forceX * ((targetScaleX - 1) * squareProps.width) / 2;
        let targetTranslateY = forceY * ((targetScaleY - 1) * squareProps.height) / 2;
        
        // Fließe langsam zum Ziel (Gummiband-Effekt wird hier erzeugt)
        // Um ein hartes Fließen zu erzeugen, würden wir die Werte direkt setzen
        // Aber für ein "flüssiges" Gefühl ist ein leichtes Smoothing besser.
        // Wir verwenden eine lineare Interpolation (lerp) für ein "flüssiges" Gefühl
        currentScaleX += (targetScaleX - currentScaleX) * flowSpeed;
        currentScaleY += (targetScaleY - currentScaleY) * flowSpeed;
        currentTranslateX += (targetTranslateX - currentTranslateX) * flowSpeed;
        currentTranslateY += (targetTranslateY - currentTranslateY) * flowSpeed;
        
        // Dämpfung: Wenn keine Kraft wirkt, fließe langsam in den Ruhezustand zurück
        if (forceX === 0) {
            currentScaleX += (1 - currentScaleX) * returnSpeed;
            currentTranslateX += (0 - currentTranslateX) * returnSpeed;
        }
        if (forceY === 0) {
            currentScaleY += (1 - currentScaleY) * returnSpeed;
            currentTranslateY += (0 - currentTranslateY) * returnSpeed;
        }

        const currentWidth = squareProps.width * currentScaleX;
        const currentHeight = squareProps.height * currentScaleY;
        
        let futureLeft = initialX + currentTranslateX - (currentWidth / 2);
        let futureRight = initialX + currentTranslateX + (currentWidth / 2);
        let futureTop = initialY + currentTranslateY - (currentHeight / 2);
        let futureBottom = initialY + currentTranslateY + (currentHeight / 2);

        // Harter Anschlag und Vibration
        const checkCollision = (isColliding, side) => {
            if (isColliding) {
                if (!collisionState[side]) {
                    if (navigator.vibrate) navigator.vibrate(50);
                    collisionState[side] = true;
                }
            } else {
                collisionState[side] = false;
            }
        };

        checkCollision(futureLeft < 0, 'left');
        checkCollision(futureRight > viewBox.width, 'right');
        checkCollision(futureTop < 0, 'top');
        checkCollision(futureBottom > viewBox.height, 'bottom');

        if (futureLeft < 0) currentTranslateX -= futureLeft;
        if (futureRight > viewBox.width) currentTranslateX -= (futureRight - viewBox.width);
        if (futureTop < 0) currentTranslateY -= futureTop;
        if (futureBottom > viewBox.height) currentTranslateY -= (futureBottom - viewBox.height);

        // Wende die finale Transformation an
        gsap.set(square, {
            x: initialX + currentTranslateX,
            y: initialY + currentTranslateY,
            scaleX: currentScaleX,
            scaleY: currentScaleY,
            transformOrigin: "center center",
        });

        requestAnimationFrame(updateAnimation); // Die Schleife fortsetzen
      }
      
      function startAnimation() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                        permissionOverlay.style.display = 'none';
                        requestAnimationFrame(updateAnimation); // Starte die Animationsschleife
                    } else {
                        permissionOverlay.innerHTML = "<p>Zugriff auf Sensoren wurde verweigert.</p>";
                    }
                })
                .catch(console.error);
        } else {
            // Für andere Geräte, die keine explizite Erlaubnis benötigen
            window.addEventListener('deviceorientation', handleOrientation);
            permissionOverlay.style.display = 'none';
            requestAnimationFrame(updateAnimation); // Starte die Animationsschleife
        }
      }

      permissionButton.addEventListener('click', startAnimation);
    });
  </script>
</body>
</html>

