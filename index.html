<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>MOTION SVG mit Gyroskop (Finale Typo)</title>
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
    }
    body {
      margin: 0;
      display: grid;
      place-items: center;
      background: #111;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }
    
    svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden; 
    }

    #permission-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #111;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      cursor: pointer;
    }
    
    #go-text {
        font-size: 2.5rem;
        font-weight: 300;
        color: rgba(255, 255, 255, 0.7);
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
    }

    #version-display {
      position: absolute;
      top: 15px;
      left: 15px;
      color: rgba(255, 255, 255, 0.3);
      font-size: 14px;
      z-index: 5;
    }
    
    #angle-display {
      position: absolute;
      top: 15px;
      right: 15px;
      color: rgba(255, 255, 255, 0.3);
      font-size: 14px;
      font-family: monospace;
      z-index: 5;
      text-align: right;
    }
  </style>
</head>
<body>

  <div id="version-display">v3.3</div>
  <div id="angle-display"></div>

  <div id="permission-overlay">
    <span id="go-text">Go</span>
  </div>

  <svg id="motion-svg" xmlns="http://www.w3.org/2000/svg" fill="white">
    <g id="word-container">
        <!-- Jeder Buchstabe ist wieder eine eigene Gruppe -->
        <g class="letter-group">
            <polygon points="300.32 269.69 243.33 269.69 131.29 269.69 58.77 269.69 17.31 269.69 17.31 779.69 131.29 779.69 131.29 661.05 187.31 779.69 243.33 661.05 243.33 779.69 357.31 779.69 357.31 269.69 300.32 269.69"/>
        </g>
        <g class="letter-group">
            <polygon points="600.18 269.69 600.18 269.69 487.23 269.69 486.2 269.69 373.25 269.69 373.25 779.69 486.2 779.69 487.23 779.69 600.18 779.69 600.18 779.69 714.15 779.69 714.15 269.69 600.18 269.69"/>
        </g>
        <g class="letter-group">
            <polygon points="1067.41 269.69 954.46 269.69 953.43 269.69 841.26 269.69 840.48 269.69 727.28 269.69 727.28 658.91 840.48 658.91 840.48 779.69 954.46 779.69 954.46 658.91 1067.41 658.91 1067.41 269.69"/>
        </g>
        <g class="letter-group">
            <rect x="1080.02" y="269.69" width="113.98" height="510"/>
        </g>
        <g class="letter-group">
            <polygon points="1434.87 269.69 1434.87 269.69 1321.92 269.69 1320.9 269.69 1207.95 269.69 1207.95 779.69 1320.9 779.69 1321.92 779.69 1434.87 779.69 1434.87 779.69 1548.85 779.69 1548.85 269.69 1434.87 269.69"/>
        </g>
        <g class="letter-group">
            <polygon points="1788.72 269.69 1788.72 391.22 1676.67 270.22 1676.67 269.69 1676.17 269.69 1562.69 269.69 1562.69 779.69 1615.54 779.69 1676.67 779.69 1788.72 779.69 1870.92 779.69 1902.69 779.69 1902.69 269.69 1788.72 269.69"/>
        </g>
    </g>
  </svg>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const permissionOverlay = document.getElementById('permission-overlay');
      const angleDisplay = document.getElementById('angle-display');
      
      const svg = document.getElementById('motion-svg');
      const container = document.getElementById('word-container');
      const letters = gsap.utils.toArray(".letter-group");
      
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      
      svg.setAttribute('viewBox', `0 0 ${screenWidth} ${screenHeight}`);
      const viewBox = { width: screenWidth, height: screenHeight };

      const wordOriginalBBox = container.getBBox();

      const neutralWidth = screenWidth * 0.5;
      const neutralHeight = neutralWidth / (wordOriginalBBox.width / wordOriginalBBox.height);
      
      const centerX = viewBox.width / 2;
      const centerY = viewBox.height / 2;
      
      // Initiale Positionierung jedes einzelnen Buchstabens
      letters.forEach(letter => {
        const letterBBox = letter.getBBox();
        letter.originalBBox = letterBBox;
        gsap.set(letter, {
            x: centerX - (letterBBox.x + letterBBox.width / 2),
            y: centerY - (letterBBox.y + letterBBox.height / 2),
            scaleX: neutralWidth / wordOriginalBBox.width,
            scaleY: neutralHeight / wordOriginalBBox.height,
            transformOrigin: "center center"
        });
      });

      let forceX = 0, forceY = 0;
      let neutralBetaCalibrated = null;
      let neutralGammaCalibrated = null;
      let animationLoopStarted = false;
      
      function handleOrientation(event) {
        const gamma = event.gamma || 0; 
        const beta = event.beta || 0;   
        
        if (neutralBetaCalibrated === null) {
            neutralBetaCalibrated = beta;
            neutralGammaCalibrated = gamma;
        }

        angleDisplay.innerHTML = `beta: ${beta.toFixed(1)} (N:${neutralBetaCalibrated.toFixed(1)})<br>gamma: ${gamma.toFixed(1)} (N:${neutralGammaCalibrated.toFixed(1)})`;

        const tiltRange = 30.0;
        const deadzone = 2.0; 

        const calibratedGamma = gamma - neutralGammaCalibrated;
        if (Math.abs(calibratedGamma) > deadzone) {
            forceX = gsap.utils.clamp(-1, 1, calibratedGamma / tiltRange);
        } else {
            forceX = 0;
        }
        
        const calibratedBeta = beta - neutralBetaCalibrated;
        if (Math.abs(calibratedBeta) > deadzone) {
            forceY = gsap.utils.clamp(-1, 1, calibratedBeta / tiltRange);
        } else {
            forceY = 0;
        }
      }

      function updateAnimation() {
        const neutralLeft = centerX - neutralWidth / 2;
        const neutralRight = centerX + neutralWidth / 2;
        const neutralTop = centerY - neutralHeight / 2;
        const neutralBottom = centerY + neutralHeight / 2;

        let newLeft = neutralLeft, newRight = neutralRight, newTop = neutralTop, newBottom = neutralBottom;
        if (forceX > 0) newRight = neutralRight + forceX * (viewBox.width - neutralRight);
        else if (forceX < 0) newLeft = neutralLeft + forceX * neutralLeft;
        
        if (forceY > 0) newBottom = neutralBottom + forceY * (viewBox.height - neutralBottom);
        else if (forceY < 0) newTop = neutralTop + forceY * neutralTop; 
        
        const newWidth = newRight - newLeft;
        const newHeight = newBottom - newTop;
        
        const isReturning = forceX === 0 && forceY === 0;
        const duration = isReturning ? 2.5 : 0.5;

        // Animiere jeden Buchstaben einzeln mit Versatz
        gsap.to(letters, { 
            x: (i, target) => {
                const letterOrigBBox = target.originalBBox;
                const letterRelX = (letterOrigBBox.x + letterOrigBBox.width / 2 - wordOriginalBBox.x) / wordOriginalBBox.width;
                const targetX = newLeft + letterRelX * newWidth;
                return targetX - (letterOrigBBox.x + letterOrigBBox.width / 2);
            },
            y: (i, target) => {
                const letterOrigBBox = target.originalBBox;
                const letterRelY = (letterOrigBBox.y + letterOrigBBox.height / 2 - wordOriginalBBox.y) / wordOriginalBBox.height;
                const targetY = newTop + letterRelY * newHeight;
                return targetY - (letterOrigBBox.y + letterOrigBBox.height / 2);
            },
            scaleX: newWidth / wordOriginalBBox.width,
            scaleY: newHeight / wordOriginalBBox.height,
            duration: duration,
            ease: "power2.out",
            stagger: 0.03
        });

        requestAnimationFrame(updateAnimation);
      }
      
      function startInteraction() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                        permissionOverlay.style.display = 'none';
                        if (!animationLoopStarted) {
                            requestAnimationFrame(updateAnimation);
                            animationLoopStarted = true;
                        }
                    } else {
                        permissionOverlay.innerHTML = "<p>Zugriff auf Sensoren wurde verweigert.</p>";
                    }
                })
                .catch(console.error);
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
            permissionOverlay.style.display = 'none';
            if (!animationLoopStarted) {
                requestAnimationFrame(updateAnimation);
                animationLoopStarted = true;
            }
        }
      }

      permissionOverlay.addEventListener('click', startInteraction);
    });
  </script>
</body>
</html>
