<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>MOTION SVG mit Gyroskop (verbreitern)</title>
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden; /* Verhindert Scrollen auf Mobilgeräten */
    }
    body {
      margin: 0;
      display: grid;
      place-items: center;
      background: #111;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }
    
    svg {
      width: min(95vw, calc(95vh * 16 / 9));
      aspect-ratio: 16 / 9;
      display: block;
      /* Wichtig, damit die Skalierung nicht abgeschnitten wird, aber die Logik verhindert den Überlauf */
      overflow: visible; 
    }

    #permission-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      text-align: center;
      color: white;
      padding: 20px;
      z-index: 10;
    }

    #permission-button {
      font-size: 1.2rem;
      padding: 15px 30px;
      margin-top: 20px;
      border-radius: 12px;
      border: 1px solid #fff;
      background-color: #333;
      color: #fff;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.2s;
    }
  </style>
</head>
<body>

  <div id="permission-overlay">
    <h1>Gyro-Interaktion</h1>
    <p>Bitte tippen, um den Zugriff auf die Bewegungssensoren zu erlauben.</p>
    <button id="permission-button">Starten</button>
  </div>

  <svg id="motion-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1920 1080" fill="white">
    <rect id="gyro-square" x="760" y="340" width="400" height="400" />
  </svg>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const permissionOverlay = document.getElementById('permission-overlay');
      const permissionButton = document.getElementById('permission-button');
      
      const square = document.getElementById('gyro-square');
      const viewBox = { width: 1920, height: 1080 };

      // Die originalen Attribute des Quadrats als Basis für Berechnungen speichern
      const squareProps = {
        x: parseFloat(square.getAttribute('x')),
        y: parseFloat(square.getAttribute('y')),
        width: parseFloat(square.getAttribute('width')),
        height: parseFloat(square.getAttribute('height')),
      };

      function handleOrientation(event) {
        const gamma = event.gamma || 0; // links/rechts (-90 bis 90)
        const beta = event.beta || 0;   // vor/zurück (-180 bis 180)

        const maxTilt = 45.0; // Sensitivität
        const deadzone = 2.0; // Kleine neutrale Zone um die Mitte

        // Normalisiere Neigungswerte, mit 45 Grad als "Nullpunkt" für Beta
        let tiltX = 0;
        if (Math.abs(gamma) > deadzone) {
            tiltX = gsap.utils.clamp(-1, 1, gamma / maxTilt);
        }
        
        let tiltY = 0;
        const calibratedBeta = beta - 45;
        if (Math.abs(calibratedBeta) > deadzone) {
            tiltY = gsap.utils.clamp(-1, 1, calibratedBeta / maxTilt);
        }
        
        // =================================================================
        // Logik für Skalierung und Ankerpunkt (`transformOrigin`)
        // =================================================================
        let targetScaleX = 1.0, targetScaleY = 1.0;
        let originX = "center", originY = "center";

        const maxScaleFactor = 2.0; // Wie stark sich das Quadrat maximal ausdehnt (z.B. 2.0 = doppelte Größe)

        // Horizontale Skalierung
        if (tiltX > 0) { // Nach rechts kippen
            originX = "left";
            targetScaleX = 1 + tiltX * (maxScaleFactor - 1);
        } else if (tiltX < 0) { // Nach links kippen
            originX = "right";
            targetScaleX = 1 + Math.abs(tiltX) * (maxScaleFactor - 1);
        }

        // Vertikale Skalierung (invertiert, wie gewünscht)
        if (tiltY > 0) { // Nach "oben" kippen (Handy wird flacher)
            originY = "bottom";
            targetScaleY = 1 + tiltY * (maxScaleFactor - 1);
        } else if (tiltY < 0) { // Nach "unten" kippen (Handy wird aufrechter)
            originY = "top";
            targetScaleY = 1 + Math.abs(tiltY) * (maxScaleFactor - 1);
        }

        // =================================================================
        // Logik zur Begrenzung am Bildschirmrand
        // =================================================================
        if (originX === "left") {
            const maxAllowedWidth = viewBox.width - squareProps.x;
            const maxAllowedScaleX = maxAllowedWidth / squareProps.width;
            if (targetScaleX > maxAllowedScaleX) targetScaleX = maxAllowedScaleX;
        } else if (originX === "right") {
            const maxAllowedWidth = squareProps.x + squareProps.width;
            const maxAllowedScaleX = maxAllowedWidth / squareProps.width;
            if (targetScaleX > maxAllowedScaleX) targetScaleX = maxAllowedScaleX;
        }

        if (originY === "bottom") {
            const maxAllowedHeight = squareProps.y + squareProps.height;
            const maxAllowedScaleY = maxAllowedHeight / squareProps.height;
            if (targetScaleY > maxAllowedScaleY) targetScaleY = maxAllowedScaleY;
        } else if (originY === "top") {
            const maxAllowedHeight = viewBox.height - squareProps.y;
            const maxAllowedScaleY = maxAllowedHeight / squareProps.height;
            if (targetScaleY > maxAllowedScaleY) targetScaleY = maxAllowedScaleY;
        }

        // Finale Animation mit den berechneten, begrenzten Werten
        gsap.to(square, {
            scaleX: targetScaleX,
            scaleY: targetScaleY,
            transformOrigin: `${originX} ${originY}`,
            duration: 0.6,
            ease: "power2.out",
            overwrite: 'auto'
        });
      }
      
      function startAnimation() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                        permissionOverlay.style.display = 'none';
                    } else {
                        permissionOverlay.innerHTML = "<p>Zugriff auf Sensoren wurde verweigert.</p>";
                    }
                })
                .catch(console.error);
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
            permissionOverlay.style.display = 'none';
        }
      }

      permissionButton.addEventListener('click', startAnimation);
    });
  </script>
</body>
</html>
